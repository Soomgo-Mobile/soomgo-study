## 📚 읽은 내용

### 4.5.2 추상 동등 비교

```javascript
var a = 42;
var b = "42";

a === b; // false
a == b; // true
```
- 해당 원리는 ToNumber() 강제 변환 일어난 후 비교

```javascript
var a = "42";
var b = true;

a == b; // false
```
- 위의 원래는 ToNumber() 값으로 강제변환이 되어, "42"는 true > 1의 값이므로 다르다.

> 결론적으로 위 사례를 통해 아래와 같은 방법을 쓰는게 좋다.
```javascript
// 암시적
if (a)


// 명시적
if (!!a)
//

// 명시적
if (Boolean( a ))
//
```
### 4.5.3 희귀 사례
- 네이티브 프로토타입을 변경한다면... valueOf 같은 값 > 정확한 비교가 되지 않는다. 왜냐하면 객체 경우 원시값으로 변환할 때 valueOf을 사용하기 때문이다.
- 강제변환이 심각한 문제가 될 경우는 7가지 이다. 하지만 나머지는 이론적으로 설명이 가능하다.

- 피연산자 중 하나가 true/false 일 가능성이 있으면 절대로 == 연산자를 쓰지 말자
- 피연산자 중 하나가 [], " ", 0이 될 가능성이 있으면 가급적 == 연산자는 쓰지 말자

### 📚 느낀점
- 네이티브 프로토타입을 변경한 경험은 없지만, 조심해야하고 완벽히 동작을 이해 했을 때 사용하지 않을까라는 생각을 했다.
- 강제변환 경우도 완벽하게 이해한 후 사유를 적는것이 협업에서도 디버깅에서도 좋을 것 같다고 다시 한번 생각하게 되었다.
- 비교 연산을 할 때, 동작하는 순서에 대해서 생각해본 것 같아 새로웠다.

### 📚 공유하고 싶은 부분(사이트)
- 