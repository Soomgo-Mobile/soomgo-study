## 📚 읽은 내용

## 4.4 암시적 변환
- 부수 효과가 명확하지 않게 숨겨진 형태로 일어나는 타입변환
- 분명하지 않은 타입 변환

### 4.4.1 `암시적`이란?

- 지저분한 코드를 감출 수 있는 이점이 있다. (저자의 주관이 포함되어 있어 설득되지는 않았....)

### 4.4.2 암시적 강제변환: 문자열 <-> 숫자
```javascript
var a = [1,2];
var b = [3,4];

a + b; // "1,23,4"
```
- 배열이 문자열로 치환되고 접합된 상황
- ES5에 따르면 수 알고리즘(피연산자가 객체 값일 경우)은 한쪽 피 연산자가 문자열이거나 다음 과정을 통해 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다.

```javascript
var a = "3.14";
var b = a - 0;

b; // 3.14
```

- 뺄셈, 곱셈, 나눗셈은 숫자에서만 일어나기 때문에, 암시적으로 숫자로 판단하여 계산한다.

### 4.4.3 암시적 강제변환: 불리언 <-> 숫자
### 4.4.4 암시적 강제변환: * <-> 불리언

### 4.4.5 &&와 || 연산자
- 해당 연산자는 논리연산자보다는 피연산자 선택 연산자라고 판단하면 된다.
- 출력으로는 앞의 값 또는 뒤의 값을 나타내는데 ToBoolean()을 통해 변환이 되어 기존 condition에 이용할 수 있다.

### 4.4.6 심벌의 강제변환
- 심벌은 숫자로 변환되지 않음
- 불리언 값으로는 명시적/암시적 모두 가능

## 4.5 느슨한/엄격한 동등 비교
- `==` 와 `===`의 차이점
- ===은 강제변환을 허용하지 않는다. (타입 체크)

### 4.5.1 비교 성능
- 성능 자체는 1마이크로 초(백만분의 1초)이니 비교는 확실하게 의도되로 할 수 있도록 한다.

### 📚 느낀점
- 생각보다 많은 곳에서 암시적으로 이용하고 있는데, 타입스크립트를 이용하면 휴먼에러나 헷갈리는 부분을 잡을 수 있다는 생각을 하였다.
- 결국에는 타입이 중요하다고 생각했고, 연산자의 의도에 맞게 써야겠구나 생각하게 되었습니다.

### 📚 공유하고 싶은 부분(사이트)
- 